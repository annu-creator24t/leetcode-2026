<-----------------Bruteforce----------------->
class Solution {
    public int longestConsecutive(int[] nums) {

        int n = nums.length;
        int longest = 0;

        for (int i = 0; i < n; i++) {

            int current = nums[i];
            int count = 1;

            while (contains(nums, current + 1)) {
                current++;
                count++;
            }

            longest = Math.max(longest, count);
        }
        return longest;
    }
    private boolean contains(int[] nums, int target) {
        for (int x : nums)
            if (x == target)
                return true;
        return false;
    }
}     // Tc=O(NÂ³) ,Sc=O(1)


<----------------Better------------------>

import java.util.*;

class Solution {
    public int longestConsecutive(int[] nums) {

        if (nums.length == 0) return 0;

        Arrays.sort(nums);

        int longest = 1;
        int count = 1;

        for (int i = 1; i < nums.length; i++) {

            if (nums[i] == nums[i-1] + 1)
                count++;

            else if (nums[i] != nums[i-1])
                count = 1;

            longest = Math.max(longest, count);
        }
        return longest;
    }
}
         //Tc=O(nlogn) ,Sc=O(1)

<-------------------Optimal------------------>

import java.util.*;

class Solution {

    public int longestConsecutive(int[] nums) {

        HashSet<Integer> set = new HashSet<>();
        for (int num : nums) set.add(num);

        int longest = 0;

        for (int num : set) {

            // start of sequence
            if (!set.contains(num - 1)) {

                int current = num;
                int count = 1;

                while (set.contains(current + 1)) {
                    current++;
                    count++;
                }

                longest = Math.max(longest, count);
            }
        }
        return longest;
    }
} // Tc=O(n),Sc=O(n)
